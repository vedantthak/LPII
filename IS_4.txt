Two numbers are said to be coprime (or relatively prime) if their greatest common divisor (GCD) is 1. In other words, they do not have any common divisors other than 1.

For example:

5 and 24 are coprime because the only number that divides both 5 and 24 is 1.

To find the GCD, we check the divisors of each number:

Divisors of 5: 
1
,
5
1,5

Divisors of 24: 
1
,
2
,
3
,
4
,
6
,
8
,
12
,
24
1,2,3,4,6,8,12,24

The only common divisor is 1, so the GCD of 5 and 24 is 1, and therefore, 5 and 24 are coprime.


output

Let's go through each step to explain how the RSA encryption and decryption process works using the given prime numbers 
ğ‘
=
5
p=5 and 
ğ‘
=
7
q=7 and message 
ğ‘€
=
3
M=3.

Step-by-Step Calculation:
1. Key Generation:
We start by calculating the public and private keys.

Step 1.1: Compute 
ğ‘›
n and 
ğœ™
(
ğ‘›
)
Ï•(n):

ğ‘›
=
ğ‘
Ã—
ğ‘
=
5
Ã—
7
=
35
n=pÃ—q=5Ã—7=35
ğœ™
(
ğ‘›
)
=
(
ğ‘
âˆ’
1
)
Ã—
(
ğ‘
âˆ’
1
)
=
(
5
âˆ’
1
)
Ã—
(
7
âˆ’
1
)
=
4
Ã—
6
=
24
Ï•(n)=(pâˆ’1)Ã—(qâˆ’1)=(5âˆ’1)Ã—(7âˆ’1)=4Ã—6=24
Step 1.2: Choose 
ğ‘’
e such that 
1
<
ğ‘’
<
ğœ™
(
ğ‘›
)
1<e<Ï•(n) and 
gcd
(
ğ‘’
,
ğœ™
(
ğ‘›
)
)
=
1
gcd(e,Ï•(n))=1.

Here, 
ğ‘’
=
5
e=5 is chosen because 
gcd
(
5
,
24
)
=
1
gcd(5,24)=1, meaning 5 is coprime with 24.

Step 1.3: Compute the modular inverse of 
ğ‘’
e modulo 
ğœ™
(
ğ‘›
)
Ï•(n) to find 
ğ‘‘
d, where 
ğ‘‘
Ã—
ğ‘’
â‰¡
1
(
m
o
d
ğœ™
(
ğ‘›
)
)
dÃ—eâ‰¡1(modÏ•(n)).

We need to find 
ğ‘‘
d such that:

ğ‘‘
Ã—
5
â‰¡
1
(
m
o
d
24
)
dÃ—5â‰¡1(mod24)
To do this, we can use the Extended Euclidean Algorithm, which gives:

5
Ã—
5
=
25
â‰¡
1
(
m
o
d
24
)
5Ã—5=25â‰¡1(mod24)
So, 
ğ‘‘
=
5
d=5.

Therefore, the public key is 
(
ğ‘’
=
5
,
ğ‘›
=
35
)
(e=5,n=35) and the private key is 
(
ğ‘‘
=
5
,
ğ‘›
=
35
)
(d=5,n=35).

2. Encryption:
To encrypt a message 
ğ‘€
M, we use the formula:

ğ¶
=
ğ‘€
ğ‘’
m
o
d
â€‰
â€‰
ğ‘›
C=M 
e
 modn
Given that 
ğ‘€
=
3
M=3, 
ğ‘’
=
5
e=5, and 
ğ‘›
=
35
n=35, we compute the ciphertext 
ğ¶
C:

ğ¶
=
3
5
m
o
d
â€‰
â€‰
35
C=3 
5
 mod35
First, calculate 
3
5
3 
5
 :

3
5
=
243
3 
5
 =243
Now, take the result modulo 35:

243
m
o
d
â€‰
â€‰
35
=
243
âˆ’
(
35
Ã—
6
)
=
243
âˆ’
210
=
33
243mod35=243âˆ’(35Ã—6)=243âˆ’210=33
So, the encrypted message is 
ğ¶
=
33
C=33.

3. Decryption:
To decrypt the ciphertext 
ğ¶
C, we use the formula:

ğ‘€
=
ğ¶
ğ‘‘
m
o
d
â€‰
â€‰
ğ‘›
M=C 
d
 modn
Given that 
ğ¶
=
33
C=33, 
ğ‘‘
=
5
d=5, and 
ğ‘›
=
35
n=35, we compute the decrypted message 
ğ‘€
M:

ğ‘€
=
33
5
m
o
d
â€‰
â€‰
35
M=33 
5
 mod35
First, calculate 
33
5
33 
5
 :

33
5
=
4182119424
33 
5
 =4182119424
Now, take the result modulo 35:

4182119424
m
o
d
â€‰
â€‰
35
=
4182119424
âˆ’
(
35
Ã—
119365984
)
=
4182119424
âˆ’
4182119420
=
4
4182119424mod35=4182119424âˆ’(35Ã—119365984)=4182119424âˆ’4182119420=4
So, 
ğ‘€
=
4
M=4, which isn't the original message 
3
3.

code explain
This code implements the RSA encryption and decryption algorithm. Let's break it down step by step:

1. Modular Exponentiation Function:
python
Copy
Edit
def power(base, expo, m):
    res = 1
    base = base % m  # Ensure the base is within the modulo range
    while expo > 0:
        if expo & 1:  # Check if the exponent is odd
            res = (res * base) % m  # Multiply the result by base if the exponent is odd
        base = (base * base) % m  # Square the base
        expo //= 2  # Reduce the exponent by half
    return res
power(base, expo, m) calculates 
base
expo
m
o
d
â€‰
â€‰
ğ‘š
base 
expo
 modm using modular exponentiation. It efficiently computes the power by repeatedly squaring the base and reducing the exponent by half.

2. Extended Euclidean Algorithm for Modular Inverse:
python
Copy
Edit
def extended_gcd(a, b):
    if b == 0:
        return a, 1, 0  # Base case: gcd(a, 0) = a, coefficients are 1 and 0
    g, x1, y1 = extended_gcd(b, a % b)  # Recursively calculate the gcd
    x = y1
    y = x1 - (a // b) * y1
    return g, x, y
extended_gcd(a, b) computes the GCD of 
ğ‘
a and 
ğ‘
b using the Euclidean algorithm and also calculates the coefficients 
ğ‘¥
x and 
ğ‘¦
y such that 
ğ‘
ğ‘¥
+
ğ‘
ğ‘¦
=
gcd
(
ğ‘
,
ğ‘
)
ax+by=gcd(a,b).

3. Modular Inverse Function:
python
Copy
Edit
def modInverse(e, phi):
    g, x, y = extended_gcd(e, phi)
    if g != 1:
        return -1  # No modular inverse exists if gcd is not 1
    return x % phi  # Return the modular inverse of e modulo phi
modInverse(e, phi) computes the modular inverse of 
ğ‘’
e modulo 
ğœ™
Ï• using the Extended Euclidean Algorithm. If the GCD of 
ğ‘’
e and 
ğœ™
Ï• is not 1, the modular inverse does not exist.

4. GCD Calculation:
python
Copy
Edit
def gcd(a, b):
    while b != 0:
        a, b = b, a % b  # Apply Euclidean algorithm to find GCD
    return a
gcd(a, b) computes the greatest common divisor of 
ğ‘
a and 
ğ‘
b using the Euclidean algorithm.

5. Prime Check:
python
Copy
Edit
def is_prime(n):
    if n < 2:
        return False  # Numbers less than 2 are not prime
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False  # If n is divisible by i, it's not prime
    return True
is_prime(n) checks if a number 
ğ‘›
n is prime by dividing it by all numbers up to 
ğ‘›
n
â€‹
 .

6. RSA Key Generation:
python
Copy
Edit
def generateKeys(p, q):
    n = p * q  # Calculate n (modulus)
    phi = (p - 1) * (q - 1)  # Calculate phi(n) (Euler's Totient function)
    
    e = 2
    while e < phi:
        if gcd(e, phi) == 1:
            break  # Find an e that is coprime with phi(n)
        e += 1
    
    d = modInverse(e, phi)  # Calculate the modular inverse of e
    if d == -1:
        raise ValueError("No modular inverse found")
    
    return e, d, n  # Return the public and private keys (e, d) and modulus n
generateKeys(p, q) generates the RSA public and private keys.

ğ‘›
=
ğ‘
Ã—
ğ‘
n=pÃ—q (modulus used for both encryption and decryption)

ğœ™
(
ğ‘›
)
=
(
ğ‘
âˆ’
1
)
Ã—
(
ğ‘
âˆ’
1
)
Ï•(n)=(pâˆ’1)Ã—(qâˆ’1) (Euler's Totient function)

Choose 
ğ‘’
e such that 
ğ‘’
e is coprime with 
ğœ™
(
ğ‘›
)
Ï•(n).

Find 
ğ‘‘
d such that 
ğ‘‘
Ã—
ğ‘’
â‰¡
1
Â 
(
modÂ 
ğœ™
(
ğ‘›
)
)
dÃ—eâ‰¡1Â (modÂ Ï•(n)) using the modular inverse function.

7. Encryption and Decryption:
python
Copy
Edit
def encrypt(m, e, n):
    return power(m, e, n)  # Encrypt the message m using the public key (e, n)

def decrypt(c, d, n):
    return power(c, d, n)  # Decrypt the ciphertext c using the private key (d, n)
encrypt(m, e, n) encrypts the message 
ğ‘š
m using the public key 
ğ‘’
e and modulus 
ğ‘›
n.

decrypt(c, d, n) decrypts the ciphertext 
ğ‘
c using the private key 
ğ‘‘
d and modulus 
ğ‘›
n.

8. Main Function to Test RSA:
python
Copy
Edit
def rsa():
    p = int(input("Enter a prime number (p): "))
    if not is_prime(p):
        print("p is not a prime number. Exiting.")
        return
    
    q = int(input("Enter another prime number (q): "))
    if not is_prime(q):
        print("q is not a prime number. Exiting.")
        return
    
    e, d, n = generateKeys(p, q)
    
    print(f"Public Key (e, n): ({e}, {n})")
    print(f"Private Key (d, n): ({d}, {n})")
    
    M = int(input("Enter a message (as a number) to encrypt: "))
    C = encrypt(M, e, n)
    print(f"Encrypted Message: {C}")
    
    decrypted = decrypt(C, d, n)
    print(f"Decrypted Message: {decrypted}")
rsa() is the main function that:

Takes two prime numbers 
ğ‘
p and 
ğ‘
q.

Generates RSA public and private keys.

Encrypts and decrypts a message.

Displays the public/private keys, encrypted message, and decrypted message.

Viva Questions and Answers (Short)
What is RSA encryption?

RSA is an asymmetric encryption algorithm that uses two keys: a public key for encryption and a private key for decryption. It relies on the difficulty of factoring large prime numbers.

Why do we use two prime numbers in RSA?

Two large prime numbers 
ğ‘
p and 
ğ‘
q are used to compute 
ğ‘›
=
ğ‘
Ã—
ğ‘
n=pÃ—q, which is part of both the public and private keys. Their product provides security since factoring large numbers is computationally difficult.

What is Euler's Totient Function (Ï†(n))?

ğœ™
(
ğ‘›
)
=
(
ğ‘
âˆ’
1
)
Ã—
(
ğ‘
âˆ’
1
)
Ï•(n)=(pâˆ’1)Ã—(qâˆ’1) where 
ğ‘
p and 
ğ‘
q are the prime numbers. It is used in RSA to calculate the private key.

What is the role of the public key?

The public key 
(
ğ‘’
,
ğ‘›
)
(e,n) is used to encrypt messages. It is made public and can be shared with anyone.

What is the role of the private key?

The private key 
(
ğ‘‘
,
ğ‘›
)
(d,n) is used to decrypt messages that were encrypted with the corresponding public key.

Why must 
ğ‘’
e be coprime with 
ğœ™
(
ğ‘›
)
Ï•(n)?

ğ‘’
e must be coprime with 
ğœ™
(
ğ‘›
)
Ï•(n) to ensure that a modular inverse 
ğ‘‘
d exists, which is essential for decryption.

How do we ensure the security of RSA?

RSA's security depends on the difficulty of factoring large composite numbers. The larger the primes 
ğ‘
p and 
ğ‘
q, the more secure the encryption.